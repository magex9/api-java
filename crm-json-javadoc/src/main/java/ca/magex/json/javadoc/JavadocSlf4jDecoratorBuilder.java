package ca.magex.json.javadoc;

import static ca.magex.json.javadoc.JavadocDelegationBuilder.buildGenerics;
import static ca.magex.json.javadoc.JavadocDelegationBuilder.buildType;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.stream.Collectors;

import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ca.magex.json.model.JsonObject;
import ca.magex.json.util.FormattedStringBuilder;

public class JavadocSlf4jDecoratorBuilder {

	private static final Logger logger = LoggerFactory.getLogger(JavadocSlf4jDecoratorBuilder.class);
	
	public static void build(String description, File inputFile, String inputPackage, String inputClass, File outputFile, String outputPackage, String outputClass) throws IOException {
		logger.info("Building logger from " + inputFile.getAbsolutePath());
		if (!inputFile.isFile())
			throw new FileNotFoundException("Could not find input interface: " + inputFile.getAbsolutePath());
		JsonObject cls = JsondocBuilder.processFile(inputFile);
		FormattedStringBuilder sb = new FormattedStringBuilder();
		sb.append("package " + outputPackage + ";");
		sb.append("");
		sb.append("/**");
		sb.append(" * AUTO-GENERATED: This file is auto-generated by " + JavadocInterfaceAdapterBuilder.class.getName());
		sb.append(" * ");
		sb.append(" * " + description);
		sb.append(" * ");
		sb.append(" * This class enables to you to inject nicely formatted slf4j logging onto any class you want.");
		sb.append(" * <dl>");
		sb.append(" *     <dd>TRACE</dd><dt>Log the method call with parameters including the result and execution time.</dt>");
		sb.append(" *     <dd>DEBUG</dd><dt>Log the method call with parameters with the execution time.</dt>");
		sb.append(" *     <dd>INFO</dd><dt>Log the method call with parameters.</dt>");
		sb.append(" *     <dd>WARNING</dd><dt>No logging</dt>");
		sb.append(" *     <dd>ERROR</dd><dt>No logging</dt>");
		sb.append(" * </dl>");
		sb.append(" * ");
		sb.append(" * @author magex");
		sb.append(" */");
		sb.indent("public class " + outputClass + buildGenerics(cls, cls) + " implements " + inputPackage + "." + cls.getString("name") + buildGenerics(cls, cls) + " {");
		sb.append("");
		sb.append("private " + inputPackage + "." + cls.getString("name") + buildGenerics(cls, cls) + " delegate;");
		sb.append("");
		sb.append("private org.slf4j.Logger logger;");
		sb.append("");
		sb.indent("public " + outputClass + "(" + inputPackage + "." + cls.getString("name") + buildGenerics(cls, cls) + " delegate, org.slf4j.Logger logger) {");
		sb.append("this.delegate = delegate;");
		sb.append("this.logger = logger;");
		sb.unindent("}");
		sb.append("");
		for (JsonObject method : cls.getArray("methods").values(JsonObject.class)) {
			buildMethod(sb, cls, method);
		}
		sb.unindent("}");
		
		logger.info("Writing file: " + outputFile.getAbsolutePath());
		FileUtils.writeStringToFile(outputFile, sb.toString(), StandardCharsets.UTF_8);
	}
	
	private static void buildMethod(FormattedStringBuilder sb, JsonObject cls, JsonObject method) {
		String methodParams = !method.contains("parameters") ? "" :
			method.getArray("parameters", JsonObject.class).stream()
				.map(o -> buildType(cls, o) + " " + o.getString("name"))
				.collect(Collectors.joining(", "));
		String loggerParams = !method.contains("parameters") ? "" :
			method.getArray("parameters", JsonObject.class).stream()
			.map(o -> "\" + " + o.getString("name") + " + \"")
			.collect(Collectors.joining(", "));
		String invokeParams = !method.contains("parameters") ? "" :
			method.getArray("parameters", JsonObject.class).stream()
			.map(o -> o.getString("name"))
			.collect(Collectors.joining(", "));
		String throwable = !method.contains("exceptions") ? "" :
			" throws " + method.getArray("exceptions", String.class).stream()
				.map(e -> cls.getObject("imports").getString(e) + "." + e).collect(Collectors.joining(", "));
		String call = method.getString("name") + "(" + loggerParams + ")";
		String generics = buildGenerics(cls, method);
		String returnType = buildType(cls, method);
		String returnClass = returnType.matches("^[a-z].*") ? "\"returnType\"" : "result.getClass()";
		sb.append("@Override");
		sb.indent("public " + (generics == null || generics.length() < 1 ? "" : generics + " ") + returnType + " " + method.getString("name") + "(" + methodParams + ")" + throwable + " {");
		sb.indent("if (logger.isTraceEnabled()) {");
		sb.append("long start = System.nanoTime();");
		sb.indent("try {");
		sb.append("logger.trace(\"Calling " + call + "\");");
		if (returnType.equals("void")) {
			sb.append("delegate." + method.getString("name") + "(" + invokeParams + ");");
			sb.append("logger.trace(\"Executed " + call + " in \" + java.time.Duration.ofNanos(System.nanoTime() - start) + \".\");");
		} else {
			sb.append(returnType + " result = delegate." + method.getString("name") + "(" + invokeParams + ");");
			sb.append("logger.trace(\"Executed " + call + " in \" + java.time.Duration.ofNanos(System.nanoTime() - start) + \" (\" + " + returnClass + " + \": \" + result + \").\");");
		}
		if (returnType.equals("void")) {
			sb.append("return;");
		} else {
			sb.append("return result;");
		}
		sb.unindent("}");
		sb.indent("catch (Exception e) {");
		sb.append("logger.trace(\"Exception on " + call + " in \" + java.time.Duration.ofNanos(System.nanoTime() - start) + \" (\" + e.getClass() + \": \" + e.getMessage() + \").\");");
		sb.append("throw e;");
		sb.unindent("}");
		sb.unindent("}");
		sb.indent("else if (logger.isDebugEnabled()) {");
		sb.append("long start = System.nanoTime();");
		sb.indent("try {");
		sb.append("logger.debug(\"Calling " + call + "\");");
		if (returnType.equals("void")) {
			sb.append("delegate." + method.getString("name") + "(" + invokeParams + ");");
			sb.append("logger.debug(\"Executed " + call + " in \" + java.time.Duration.ofNanos(System.nanoTime() - start) + \".\");");
		} else {
			sb.append(returnType + " result = delegate." + method.getString("name") + "(" + invokeParams + ");");
			sb.append("logger.debug(\"Executed " + call + " in \" + java.time.Duration.ofNanos(System.nanoTime() - start) + \".\");");
		}
		if (returnType.equals("void")) {
			sb.append("return;");
		} else {
			sb.append("return result;");
		}
		sb.unindent("}");
		sb.indent("catch (Exception e) {");
		sb.append("logger.debug(\"Exception on " + call + " in \" + java.time.Duration.ofNanos(System.nanoTime() - start) + \" (\" + e.getClass() + \": \" + e.getMessage() + \").\");");
		sb.append("throw e;");
		sb.unindent("}");
		sb.unindent("}");
		sb.indent("else if (logger.isInfoEnabled()) {");
		sb.append("logger.info(\"Calling " + call + "\");");
		if (returnType.equals("void")) {
			sb.append("delegate." + method.getString("name") + "(" + invokeParams + ");");
		} else {
			sb.append("return delegate." + method.getString("name") + "(" + invokeParams + ");");
		}
		sb.unindent("}");
		sb.indent("else {");
		if (returnType.equals("void")) {
			sb.append("delegate." + method.getString("name") + "(" + invokeParams + ");");
		} else {
			sb.append("return delegate." + method.getString("name") + "(" + invokeParams + ");");
		}
		sb.unindent("}");
		sb.unindent("}");
		sb.append("");
	}

}
